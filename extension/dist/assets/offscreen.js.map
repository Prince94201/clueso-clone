{"version":3,"file":"offscreen.js","sources":["../../src/offscreen/offscreen.ts"],"sourcesContent":["let recorder: MediaRecorder | null = null;\nlet recordedChunks: BlobPart[] = [];\nlet activeStream: MediaStream | null = null;\n\nfunction stopTracks(stream: MediaStream | null) {\n  if (!stream) return;\n  for (const t of stream.getTracks()) t.stop();\n}\n\nasync function getTabStream(streamId: string): Promise<MediaStream> {\n  // Important: use getUserMedia with chromeMediaSourceId (works with tabCapture.getMediaStreamId)\n  return await navigator.mediaDevices.getUserMedia({\n    video: {\n      // @ts-ignore - Chrome-specific constraint\n      mandatory: {\n        chromeMediaSource: 'tab',\n        chromeMediaSourceId: streamId\n      }\n    },\n    audio: {\n      // tab audio\n      // @ts-ignore - Chrome-specific constraint\n      mandatory: {\n        chromeMediaSource: 'tab',\n        chromeMediaSourceId: streamId\n      }\n    }\n  } as any);\n}\n\nasync function getMicStream(): Promise<MediaStream> {\n  return await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n}\n\nfunction mixAudioStreams(streams: MediaStream[]): MediaStreamTrack | null {\n  const audioTracks = streams.flatMap((s) => s.getAudioTracks());\n  if (audioTracks.length === 0) return null;\n\n  const ctx = new AudioContext();\n  const destination = ctx.createMediaStreamDestination();\n\n  for (const track of audioTracks) {\n    const src = ctx.createMediaStreamSource(new MediaStream([track]));\n    src.connect(destination);\n  }\n\n  return destination.stream.getAudioTracks()[0] ?? null;\n}\n\nasync function startRecording(streamId: string, withMic: boolean) {\n  if (recorder) return;\n\n  recordedChunks = [];\n\n  const tabStream = await getTabStream(streamId);\n  let micStream: MediaStream | null = null;\n\n  if (withMic) {\n    try {\n      micStream = await getMicStream();\n    } catch {\n      micStream = null;\n    }\n  }\n\n  const tracks: MediaStreamTrack[] = [];\n  // video from tab\n  const videoTrack = tabStream.getVideoTracks()[0];\n  if (videoTrack) tracks.push(videoTrack);\n\n  // mix tab audio + mic audio if present\n  const mixedAudio = mixAudioStreams([tabStream, ...(micStream ? [micStream] : [])]);\n  if (mixedAudio) tracks.push(mixedAudio);\n\n  activeStream = new MediaStream(tracks);\n\n  const mimeTypeCandidates = [\n    'video/webm;codecs=vp9,opus',\n    'video/webm;codecs=vp8,opus',\n    'video/webm'\n  ];\n\n  const mimeType = mimeTypeCandidates.find((t) => MediaRecorder.isTypeSupported(t)) ?? '';\n\n  recorder = new MediaRecorder(activeStream, mimeType ? { mimeType } : undefined);\n\n  recorder.ondataavailable = (e) => {\n    if (e.data && e.data.size > 0) recordedChunks.push(e.data);\n  };\n\n  recorder.start(1000);\n\n  // cleanup mic stream tracks (video none) when tab ends too\n  tabStream.getTracks().forEach((t) =>\n    t.addEventListener('ended', () => {\n      // tab capture ended by user\n      void stopRecording();\n    })\n  );\n}\n\nasync function stopRecording(): Promise<{ url: string; filename: string } | null> {\n  if (!recorder) return null;\n\n  const localRecorder = recorder;\n  recorder = null;\n\n  await new Promise<void>((resolve) => {\n    localRecorder.onstop = () => resolve();\n    localRecorder.stop();\n  });\n\n  const blob = new Blob(recordedChunks, { type: 'video/webm' });\n  recordedChunks = [];\n\n  stopTracks(activeStream);\n  activeStream = null;\n\n  const url = URL.createObjectURL(blob);\n  const filename = `recording-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;\n\n  return { url, filename };\n}\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  (async () => {\n    if (message?.type === 'OFFSCREEN_START') {\n      await startRecording(message.streamId, Boolean(message.withMic));\n      sendResponse({ ok: true });\n      return;\n    }\n\n    if (message?.type === 'OFFSCREEN_STOP') {\n      const result = await stopRecording();\n      sendResponse({ ok: true, result });\n      return;\n    }\n\n    sendResponse({ ok: false, error: 'Unknown message' });\n  })().catch((err) => sendResponse({ ok: false, error: String(err?.message ?? err) }));\n\n  return true;\n});\n"],"names":["recorder","recordedChunks","activeStream","stopTracks","stream","t","getTabStream","streamId","getMicStream","mixAudioStreams","streams","audioTracks","s","ctx","destination","track","startRecording","withMic","tabStream","micStream","tracks","videoTrack","mixedAudio","mimeType","e","stopRecording","localRecorder","resolve","blob","url","filename","message","_sender","sendResponse","result","err"],"mappings":"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"}